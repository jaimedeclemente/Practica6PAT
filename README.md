# Practica6PAT
## Testing101

En esta práctica nos hemos introducido a los conceptos del testing. Para ello, hemos hecho dos tipos de tests distintos:

* **Dos tests unitarios:** Hemos hecho dos tests de las funciones existentes en los archivos *DNI.java* y *Telefono.java*
* **Dos tests E2E:** Hemos hecho dos tests E2E de dos endpoints del controller existente, llamado *ProcessController.java*

Así, hemos desarrollado 7 funciones test: 1 por cada test unitario y, dentro de los tests E2E , 1 función para el funcionamiento correcto y otra para el incorrecto. Estas funciones se incluyen en las clases DNITest, TelefonoTest y ProcessControllerTest. Su funcionamiento es:

* **DNITest:** Al ser un test unitario, su funcionamiento era bastante sencillo. La idea era provar la función *validar* y comprobar que las respuestas que daba eran las que deberían salir según lo que le introducíamos. Esta función devolvía un *true* en caso de que el *String* introducido como posible DNI tuviese el formato correcto y un *false* en caso contrario. Por esa razón, lo que hicimos fue probar distintos casos en los que el DNI no tenía el formato correcto, sea por que la letra no era la que debía o porque no cumplía la estructura necesaria (para el primer caso se eligieron algunos que ofrecía el Ministerio del Interior), y comprobamos que el resultado de la función era el esperado, en este caso un *false*. Después, introducimos una serie de DNIs que sí que debían ser correctos y comprobamos que la funcón *validar* devolvía *true*.

* **TelefonoTest:** De manera muy parecida al apartado anterior, comprobamos de la misma manera la función *validar*, esta vez de *Telefono.java*. Al igual que antes, se comprueba primero que los teléfonos con formato incorrecto devuelvan un *false* y, los correctos, un *true*. Sin embargo, en este punto pudimos ver la utilidad del testing pues, al meter un teléfono con 10 dígitos que, en principio, no debería pasar correctamente, pasa. En la realidad, deberíamos ver qué le sucede al código para que esto pase y arreglarlo.

* **ProcessControllerTest:** En este caso, como se realiza un test sobre un *Controller*, los tests se harán sobre dos endpoints específicos (que, para provar diferentes casos, serán un *get* y un *post*). A la hora de hacer un test, y a fin de que sea E2E, debemos comprobar tanto la casuística correcta como la incorrecta. Por todo ello, tendremos 4 funciones. Antes de empezar, creamos un puerto en el que deberían estar ejecutándose los endpoints y un *RestTemplate*.  
    * **GetMapping:** La función del *ProcessController* que testearemos en este caso es *processData*. Es por ello que, las funciones que hacen el test las he llamado *processDataTestOK* y *processDataTestKO*. En la primera, creamos la *url* a la que deberíamos acceder y le metemos a través de un request datos que, en principio, deberían ser correctos. Más tarde, nos creamos las diferentes respuestas que creemos que deberían salir y comprobamos que las que realmente salen son iguales. De la misma manera, en la segunda función hacemos un proceso parecido pero con datos erróneos. Es por ello que se sustituye el mensaje esperado a "KO". Cabe destacar que siempre se comprueba que el estatus de la respuesta sea un código 200 (OK) porque la función siempre lo hace de esta manera, cambiando simplemente el mensaje que devuelve en unos casos y otros.
    * **PostMapping:** En este caso la función testeada es *processDataLegacy*. Al igual que antes, he llamado a las funciones para hacer el test con los nombres *processDataLegacyTestOK* y *processDataLegacyTestKO*. En este caso, nos tenemos que formar el JSON que se incluye en el request, que se hace a través de un *Map*. 
